
# tinyre  

A tiny regex engine.  
一个微型的有点特别的 python 风格正则引擎。  

许可协议：**zlib license**

## 程序设计

### 工作方式
将正则表达式编译为一种简单的脚本语言(简单到差不多是另一种正则写法)，  
然后匹配时对其进行解释

### 数据结构

**回溯栈**  
用于支持选择支和NFA回溯，其单体数据结构为：

    strut btstack_node {  
        char* re;  
        char* s;  
    }

### 指令

**显式指令**  
定义：直接出现在编译后表达式中的指令，以 : 表示指令开始和结束

__:p    压栈指令(push)__  
在回溯栈中压入一个值，这个值由当前的s和re组成  
用于 选择支(即|或[],暂未实现) 和 ?.*的工作及回溯 中

__:-    弃栈指令(dump stack)__  
无效化下一个压栈指令

__:jn:  跳转指令(jump)__  
n 为一个数字，说明了跳转的偏移量  
偏移量直接以char为单位，转义字符算2个长度。  
偏移量以左方或右方冒号为0位置开始计数。  
跳转指令作用于 re ，不对文本s产生任何影响  

以下指令未完成：  
__\:cn\: 计数跳转(count jump)__  
待编辑

__:e    计数清除(erase)__  
待编辑

__:<n: 小于__  
待编辑

__:<n: 大于__  
待编辑

**隐式指令**  
定义：并不直接出现在编译后表达式中的指令

__比较指令__  
比较表达式当前字符与文本是否匹配，  
匹配则s++,re++，不匹配则调用返回指令  

__出栈指令__  
在回溯栈中取出一个值。  
被返回指令调用。

__返回指令__  
若回溯栈中无数据，函数返回  
若回溯栈中有数据，读出s指针位置，读出re指针位置，并且re++(伪码)  
关于re++：  
若随后是一个组，则一直加到组后面  
若随后是jmp指令，直接忽略并跳过(这主要是为n*准备的)  
若随后是一个组，组后有一个jmp指令，两个都会跳过  
被比较指令调用。

### 编译过程  

1. 将所有 : 转化为 \\:
2. 一般性文本 及 . \g \d 等原样保留
3. 分组括号原样保留
4. n? 转化为 :p n (无空格)
5. n* 转化为 :p n :j-3: (无空格)
6. n+ 转化为 :- :p n :j-3: (无空格)
7. [abc] 转化为 :p a :j8: :p b :j1: c (无空格)

